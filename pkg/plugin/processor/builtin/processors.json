[
  {
    "specification": {
      "name": "avro.encode",
      "summary": "Encodes a record's field into the Avro format",
      "description": "The processor takes a record's field and encodes it using a schema into the [Avro format](https://avro.apache.org/).\nIt provides two strategies for determining the schema:\n\n* **preRegistered** (recommended)\n  This strategy downloads an existing schema from the schema registry and uses it to encode the record.\n  This requires the schema to already be registered in the schema registry. The schema is downloaded\n  only once and cached locally.\n* **autoRegister** (for development purposes)\n  This strategy infers the schema by inspecting the structured data and registers it in the schema\n  registry. If the record schema is known in advance it's recommended to use the preRegistered strategy\n  and manually register the schema, as this strategy comes with limitations.\n\n  The strategy uses reflection to traverse the structured data of each record and determine the type\n  of each field. If a specific field is set to nil the processor won't have enough information to determine\n  the type and will default to a nullable string. Because of this it is not guaranteed that two records\n  with the same structure produce the same schema or even a backwards compatible schema. The processor\n  registers each inferred schema in the schema registry with the same subject, therefore the schema compatibility\n  checks need to be disabled for this schema to prevent failures. If the schema subject does not exist before running\n  this processor, it will automatically set the correct compatibility settings in the schema registry.\n\nThis processor is the counterpart to [`avro.decode`](/docs/processors/builtin/avro.decode).",
      "version": "v0.1.0",
      "author": "Meroxa, Inc.",
      "parameters": {
        "auth.basic.password": {
          "default": "",
          "description": "The password to use with basic authentication. This option is required if\nauth.basic.username contains a value. If both auth.basic.username and auth.basic.password\nare empty basic authentication is disabled.",
          "type": "string",
          "validations": []
        },
        "auth.basic.username": {
          "default": "",
          "description": "The username to use with basic authentication. This option is required if\nauth.basic.password contains a value. If both auth.basic.username and auth.basic.password\nare empty basic authentication is disabled.",
          "type": "string",
          "validations": []
        },
        "field": {
          "default": ".Payload.After",
          "description": "The field that will be encoded.",
          "type": "string",
          "validations": []
        },
        "schema.autoRegister.subject": {
          "default": "",
          "description": "The subject name under which the inferred schema will be registered in the schema registry.",
          "type": "string",
          "validations": []
        },
        "schema.preRegistered.subject": {
          "default": "",
          "description": "The subject of the schema in the schema registry used to encode the record.",
          "type": "string",
          "validations": []
        },
        "schema.preRegistered.version": {
          "default": "",
          "description": "The version of the schema in the schema registry used to encode the record.",
          "type": "int",
          "validations": [
            {
              "type": "greater-than",
              "value": "0"
            }
          ]
        },
        "schema.strategy": {
          "default": "",
          "description": "Strategy to use to determine the schema for the record.\nAvailable strategies are:\n* `preRegistered` (recommended) - Download an existing schema from the schema registry.\n   This strategy is further configured with options starting with `schema.preRegistered.*`.\n* `autoRegister` (for development purposes) - Infer the schema from the record and register it\n   in the schema registry. This strategy is further configured with options starting with\n  `schema.autoRegister.*`.\n\nFor more information about the behavior of each strategy read the main processor description.",
          "type": "string",
          "validations": [
            {
              "type": "required",
              "value": ""
            },
            {
              "type": "inclusion",
              "value": "preRegistered,autoRegister"
            }
          ]
        },
        "tls.ca.cert": {
          "default": "",
          "description": "The path to a file containing PEM encoded CA certificates. If this option is empty,\nConduit falls back to using the host's root CA set.",
          "type": "string",
          "validations": []
        },
        "tls.client.cert": {
          "default": "",
          "description": "The path to a file containing a PEM encoded certificate. This option is required\nif tls.client.key contains a value. If both tls.client.cert and tls.client.key are empty\nTLS is disabled.",
          "type": "string",
          "validations": []
        },
        "tls.client.key": {
          "default": "",
          "description": "The path to a file containing a PEM encoded private key. This option is required\nif tls.client.cert contains a value. If both tls.client.cert and tls.client.key are empty\nTLS is disabled.",
          "type": "string",
          "validations": []
        },
        "url": {
          "default": "",
          "description": "URL of the schema registry (e.g. http://localhost:8085)",
          "type": "string",
          "validations": [
            {
              "type": "required",
              "value": ""
            }
          ]
        }
      }
    },
    "examples": [
      {
        "description": "This example shows the usage of the `avro.decode` processor.\nThe processor decodes the record's`.Key` field using the schema that is\ndownloaded from the schema registry and needs to exist under the subject`example-decode`.\nIn this example we use the following schema:\n\n```json\n{\n  \"type\":\"record\",\n  \"name\":\"record\",\n  \"fields\":[\n    {\"name\":\"myString\",\"type\":\"string\"},\n    {\"name\":\"myInt\",\"type\":\"int\"}\n  ]\n}\n```",
        "config": {
          "auth.basic.password": "",
          "auth.basic.username": "",
          "field": ".Key",
          "tls.ca.cert": "",
          "tls.client.cert": "",
          "tls.client.key": "",
          "url": "http://127.0.0.1:54322"
        },
        "have": {
          "position": "dGVzdC1wb3NpdGlvbg==",
          "operation": "create",
          "metadata": {
            "key1": "val1"
          },
          "key": "\u0000\u0000\u0000\u0000\u0001\u0006bar\u0002",
          "payload": {
            "before": null,
            "after": null
          }
        },
        "want": {
          "position": "dGVzdC1wb3NpdGlvbg==",
          "operation": "create",
          "metadata": {
            "key1": "val1"
          },
          "key": {
            "myInt": 1,
            "myString": "bar"
          },
          "payload": {
            "before": null,
            "after": null
          }
        }
      },
      {
        "description": "This example shows the usage of the `avro.encode` processor\nwith the `autoRegister` schema strategy. The processor encodes the record's\n`.Payload.After` field using the schema that is extracted from the data\nand registered on the fly under the subject`example-autoRegister`.",
        "config": {
          "auth.basic.password": "",
          "auth.basic.username": "",
          "field": ".Payload.After",
          "schema.autoRegister.subject": "example-autoRegister",
          "schema.preRegistered.subject": "",
          "schema.preRegistered.version": "",
          "schema.strategy": "autoRegister",
          "tls.ca.cert": "",
          "tls.client.cert": "",
          "tls.client.key": "",
          "url": "http://127.0.0.1:54322"
        },
        "have": {
          "position": "dGVzdC1wb3NpdGlvbg==",
          "operation": "create",
          "metadata": {
            "key1": "val1"
          },
          "key": null,
          "payload": {
            "before": null,
            "after": {
              "myFloat": 2.3,
              "myInt": 1,
              "myMap": {
                "bar": 2.2,
                "foo": true
              },
              "myString": "bar",
              "myStruct": {
                "bar": false,
                "foo": 1
              }
            }
          }
        },
        "want": {
          "position": "dGVzdC1wb3NpdGlvbg==",
          "operation": "create",
          "metadata": {
            "key1": "val1"
          },
          "key": null,
          "payload": {
            "before": null,
            "after": "\u0000\u0000\u0000\u0000\u0001ffffff\u0002@\u0002\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0001@\u0001\u0006bar\u0000\u0002"
          }
        }
      },
      {
        "description": "This example shows the usage of the `avro.encode` processor\nwith the `preRegistered` schema strategy. When using this strategy, the\nschema has to be manually pre-registered. In this example we use the following schema:\n\n```json\n{\n  \"type\":\"record\",\n  \"name\":\"record\",\n  \"fields\":[\n    {\"name\":\"myString\",\"type\":\"string\"},\n    {\"name\":\"myInt\",\"type\":\"int\"}\n  ]\n}\n```\n\nThe processor encodes the record's`.Key` field using the above schema.",
        "config": {
          "auth.basic.password": "",
          "auth.basic.username": "",
          "field": ".Key",
          "schema.autoRegister.subject": "",
          "schema.preRegistered.subject": "example-preRegistered",
          "schema.preRegistered.version": "1",
          "schema.strategy": "preRegistered",
          "tls.ca.cert": "",
          "tls.client.cert": "",
          "tls.client.key": "",
          "url": "http://127.0.0.1:54322"
        },
        "have": {
          "position": "dGVzdC1wb3NpdGlvbg==",
          "operation": "create",
          "metadata": {
            "key1": "val1"
          },
          "key": {
            "myInt": 1,
            "myString": "bar"
          },
          "payload": {
            "before": null,
            "after": null
          }
        },
        "want": {
          "position": "dGVzdC1wb3NpdGlvbg==",
          "operation": "create",
          "metadata": {
            "key1": "val1"
          },
          "key": "\u0000\u0000\u0000\u0000\u0001\u0006bar\u0002",
          "payload": {
            "before": null,
            "after": null
          }
        }
      }
    ]
  },
  {
    "specification": {
      "name": "base64.decode",
      "summary": "Decode a field to base64.",
      "description": "The processor will decode the value of the target field from base64 and store the\nresult in the target field. It is not allowed to decode the `.Position` field.",
      "version": "v0.1.0",
      "author": "Meroxa, Inc.",
      "parameters": {
        "field": {
          "default": "",
          "description": "Field is the target field, as it would be addressed in a Go template (e.g. `.Payload.After.foo`).\nNote that it is not allowed to base64 decode the `.Position` field.",
          "type": "string",
          "validations": [
            {
              "type": "required",
              "value": ""
            },
            {
              "type": "exclusion",
              "value": ".Position"
            }
          ]
        }
      }
    },
    "examples": [
      {
        "description": "This example decodes the base64 encoded string stored in\n`.Payload.After`. Note that the result is a string, so if you want to\nfurther process the result (e.g. parse the string as JSON), you need to chain\nother processors (e.g. [`json.decode`](/docs/processors/builtin/decode.json)).",
        "config": {
          "field": ".Payload.After.foo"
        },
        "have": {
          "position": "dGVzdC1wb3NpdGlvbg==",
          "operation": "create",
          "metadata": {
            "key1": "val1"
          },
          "key": "test-key",
          "payload": {
            "before": null,
            "after": {
              "foo": "YmFy"
            }
          }
        },
        "want": {
          "position": "dGVzdC1wb3NpdGlvbg==",
          "operation": "create",
          "metadata": {
            "key1": "val1"
          },
          "key": "test-key",
          "payload": {
            "before": null,
            "after": {
              "foo": "bar"
            }
          }
        }
      }
    ]
  },
  {
    "specification": {
      "name": "base64.encode",
      "summary": "Encode a field to base64.",
      "description": "The processor will encode the value of the target field to base64 and store the\nresult in the target field. It is not allowed to encode the `.Position` field.\nIf the provided field doesn't exist, the processor will create that field and\nassign its value.",
      "version": "v0.1.0",
      "author": "Meroxa, Inc.",
      "parameters": {
        "field": {
          "default": "",
          "description": "Field is the target field, as it would be addressed in a Go template (e.g. `.Payload.After.foo`).\nNote that it is not allowed to base64 encode the `.Position` field.",
          "type": "string",
          "validations": [
            {
              "type": "required",
              "value": ""
            },
            {
              "type": "exclusion",
              "value": ".Position"
            }
          ]
        }
      }
    },
    "examples": [
      {
        "description": "This example encodes a single value stored in `.Payload.After.foo`\ninto a base64 encoded string.",
        "config": {
          "field": ".Payload.After.foo"
        },
        "have": {
          "position": "dGVzdC1wb3NpdGlvbg==",
          "operation": "create",
          "metadata": {
            "key1": "val1"
          },
          "key": "test-key",
          "payload": {
            "before": null,
            "after": {
              "foo": "bar"
            }
          }
        },
        "want": {
          "position": "dGVzdC1wb3NpdGlvbg==",
          "operation": "create",
          "metadata": {
            "key1": "val1"
          },
          "key": "test-key",
          "payload": {
            "before": null,
            "after": {
              "foo": "YmFy"
            }
          }
        }
      },
      {
        "description": "This example encodes the raw payload stored in `.Key`\ninto a base64 encoded string.",
        "config": {
          "field": ".Key"
        },
        "have": {
          "position": "dGVzdC1wb3NpdGlvbg==",
          "operation": "create",
          "metadata": {
            "key1": "val1"
          },
          "key": "test-key",
          "payload": {
            "before": null,
            "after": {
              "foo": "bar"
            }
          }
        },
        "want": {
          "position": "dGVzdC1wb3NpdGlvbg==",
          "operation": "create",
          "metadata": {
            "key1": "val1"
          },
          "key": "dGVzdC1rZXk=",
          "payload": {
            "before": null,
            "after": {
              "foo": "bar"
            }
          }
        }
      }
    ]
  },
  {
    "specification": {
      "name": "custom.javascript",
      "summary": "JavaScript processor",
      "description": "A processor that makes it possible to process Conduit records using JavaScript.\n\nThe following helper functions and fields are available:\n* logger: a logger that outputs to Conduit's logs. Check zerolog's API on how to use it.\n* Record(): constructs a new record which represents a successful processing result.\nIt's analogous to sdk.SingleRecord from Conduit's Go processor SDK.\n* RawData(): creates a raw data object. It's analogous to opencdc.RawData. Optionally, it\naccepts a string argument, which will be cast into a byte array, for example: record.Key = RawData(\"new key\").\n* StructuredData(): creates a structured data (map-like) object.\n\nTo find out what's possible with the JS processors, also refer to the documentation for \n[goja](https://github.com/dop251/goja), which is the JavaScript engine we use.",
      "version": "v0.1.0",
      "author": "Meroxa, Inc.",
      "parameters": {
        "script": {
          "default": "",
          "description": "JavaScript code for this processor.\nIt needs to have a function `process()` that accept\na record and returns a record.\nThe `process()` function can either modify the input record and return it,\nor create a new record.\nIf a record needs to be filtered (dropped from the pipeline),\nthen the `process()` function should return a `null`.",
          "type": "string",
          "validations": []
        },
        "script.path": {
          "default": "",
          "description": "The path to a .js file containing the processor code.",
          "type": "string",
          "validations": []
        }
      }
    },
    "examples": [
      {
        "description": "",
        "config": {
          "script": "function process(rec) {\n  rec.Metadata[\"processed\"] = \"true\";\n  let existing = String.fromCharCode.apply(String, rec.Payload.After);\n  rec.Payload.After = RawData(\"hello, \" + existing);\n  return rec;\n}",
          "script.path": ""
        },
        "have": {
          "position": null,
          "operation": "Operation(0)",
          "metadata": {
            "existing-key": "existing-value"
          },
          "key": null,
          "payload": {
            "before": null,
            "after": "world"
          }
        },
        "want": {
          "position": null,
          "operation": "Operation(0)",
          "metadata": {
            "existing-key": "existing-value",
            "processed": "true"
          },
          "key": null,
          "payload": {
            "before": null,
            "after": "hello, world"
          }
        }
      }
    ]
  },
  {
    "specification": {
      "name": "field.convert",
      "summary": "Convert the type of a field.",
      "description": "Convert takes the field of one type and converts it into another type (e.g. string to integer). \nThe applicable types are string, int, float and bool. Converting can be done between any combination of types. Note that\nbooleans will be converted to numeric values 1 (true) and 0 (false). Processor is only applicable to .Key, .Payload.Before\nand .Payload.After prefixes, and only applicable if said fields contain structured data.\nIf the record contains raw JSON data, then use the processor \"decode.json\" to parse it into structured data first.",
      "version": "v0.1.0",
      "author": "Meroxa, Inc.",
      "parameters": {
        "field": {
          "default": "",
          "description": "Field is the target field, as it would be addressed in a Go template (e.g. `.Payload.After.foo`).\nyou can only convert fields that are under .Key and .Payload, and said fields should contain structured data.",
          "type": "string",
          "validations": [
            {
              "type": "required",
              "value": ""
            },
            {
              "type": "regex",
              "value": "^\\.(Payload|Key).*"
            }
          ]
        },
        "type": {
          "default": "",
          "description": "Type is the target field type after conversion, available options are: string, int, float, bool.",
          "type": "string",
          "validations": [
            {
              "type": "required",
              "value": ""
            },
            {
              "type": "inclusion",
              "value": "string,int,float,bool"
            }
          ]
        }
      }
    },
    "examples": [
      {
        "description": "change .Key.id type to int",
        "config": {
          "field": ".Key.id",
          "type": "int"
        },
        "have": {
          "position": null,
          "operation": "update",
          "metadata": null,
          "key": {
            "id": "123"
          },
          "payload": {
            "before": null,
            "after": {
              "foo": "bar"
            }
          }
        },
        "want": {
          "position": null,
          "operation": "update",
          "metadata": null,
          "key": {
            "id": 123
          },
          "payload": {
            "before": null,
            "after": {
              "foo": "bar"
            }
          }
        }
      },
      {
        "description": "change .Key.id type to string",
        "config": {
          "field": ".Key.id",
          "type": "string"
        },
        "have": {
          "position": null,
          "operation": "update",
          "metadata": null,
          "key": {
            "id": 123.345
          },
          "payload": {
            "before": null,
            "after": {
              "foo": "bar"
            }
          }
        },
        "want": {
          "position": null,
          "operation": "update",
          "metadata": null,
          "key": {
            "id": "123.345"
          },
          "payload": {
            "before": null,
            "after": {
              "foo": "bar"
            }
          }
        }
      },
      {
        "description": "change .Payload.After.done type to bool",
        "config": {
          "field": ".Payload.After.done",
          "type": "bool"
        },
        "have": {
          "position": null,
          "operation": "update",
          "metadata": null,
          "key": {
            "id": "123"
          },
          "payload": {
            "before": null,
            "after": {
              "done": "1"
            }
          }
        },
        "want": {
          "position": null,
          "operation": "update",
          "metadata": null,
          "key": {
            "id": "123"
          },
          "payload": {
            "before": null,
            "after": {
              "done": true
            }
          }
        }
      }
    ]
  },
  {
    "specification": {
      "name": "field.rename",
      "summary": "Rename a group of fields.",
      "description": "Rename a group of field names to new names. It is not allowed to rename top-level fields (.Operation, .Position, \n.Key, .Metadata, .Payload.Before, .Payload.After).\nNote that this processor only runs on structured data, if the record contains raw JSON data, then use the processor \"decode.json\" to parse it into structured data first.",
      "version": "v0.1.0",
      "author": "Meroxa, Inc.",
      "parameters": {
        "mapping": {
          "default": "",
          "description": "Mapping is a comma separated list of keys and values for fields and their new names (keys and values\nare separated by colons \":\"). For example: `.Metadata.key:id,.Payload.After.foo:bar`.",
          "type": "string",
          "validations": [
            {
              "type": "required",
              "value": ""
            }
          ]
        }
      }
    },
    "examples": [
      {
        "description": "Rename two fields, one under key, and one under payload.before.",
        "config": {
          "mapping": ".Key.id:table,.Payload.Before.bar:renamedBar"
        },
        "have": {
          "position": null,
          "operation": "create",
          "metadata": {
            "key1": "val1"
          },
          "key": {
            "id": "table-name"
          },
          "payload": {
            "before": {
              "bar": "baz"
            },
            "after": {
              "foo": "bar"
            }
          }
        },
        "want": {
          "position": null,
          "operation": "create",
          "metadata": {
            "key1": "val1"
          },
          "key": {
            "table": "table-name"
          },
          "payload": {
            "before": {
              "renamedBar": "baz"
            },
            "after": {
              "foo": "bar"
            }
          }
        }
      },
      {
        "description": "Rename two fields, one under metadata, and one under payload.after.",
        "config": {
          "mapping": ".Metadata.key1:newKey,.Payload.After.foo:newFoo"
        },
        "have": {
          "position": null,
          "operation": "create",
          "metadata": {
            "key1": "val1"
          },
          "key": null,
          "payload": {
            "before": {
              "bar": "baz"
            },
            "after": {
              "foo": "bar"
            }
          }
        },
        "want": {
          "position": null,
          "operation": "create",
          "metadata": {
            "newKey": "val1"
          },
          "key": null,
          "payload": {
            "before": {
              "bar": "baz"
            },
            "after": {
              "newFoo": "bar"
            }
          }
        }
      }
    ]
  },
  {
    "specification": {
      "name": "field.set",
      "summary": "Set the value of a certain field.",
      "description": "Set the value of a certain field to any value. It is not allowed to set the .Position field.\nThe new value can be a Go template expression, the processor will evaluate the output and assign the value to the target field.\nIf the \"field\" provided doesn't exist, the processor will create that field and assign its value.\nThis processor can be used for multiple purposes, like extracting fields, hoisting data, inserting fields, copying fields, masking fields, etc.\nNote that this processor only runs on structured data, if the record contains raw JSON data, then use the processor\n\"decode.json\" to parse it into structured data first.",
      "version": "v0.1.0",
      "author": "Meroxa, Inc.",
      "parameters": {
        "field": {
          "default": "",
          "description": "Field is the target field, as it would be addressed in a Go template (e.g. `.Payload.After.foo`).\nNote that it is not allowed to set the .Position field.",
          "type": "string",
          "validations": [
            {
              "type": "required",
              "value": ""
            },
            {
              "type": "exclusion",
              "value": ".Position"
            }
          ]
        },
        "value": {
          "default": "",
          "description": "Value is a Go template expression which will be evaluated and stored in `field` (e.g. `{{ .Payload.After }}`).",
          "type": "string",
          "validations": [
            {
              "type": "required",
              "value": ""
            }
          ]
        }
      }
    },
    "examples": [
      {
        "description": "Processor will create a new field and set its value",
        "config": {
          "field": ".Payload.After.foo",
          "value": "bar"
        },
        "have": {
          "position": null,
          "operation": "snapshot",
          "metadata": null,
          "key": {
            "my-key": "id"
          },
          "payload": {
            "before": null,
            "after": null
          }
        },
        "want": {
          "position": null,
          "operation": "snapshot",
          "metadata": null,
          "key": {
            "my-key": "id"
          },
          "payload": {
            "before": null,
            "after": {
              "foo": "bar"
            }
          }
        }
      },
      {
        "description": "Processor will set the operation into \"update\".",
        "config": {
          "field": ".Operation",
          "value": "update"
        },
        "have": {
          "position": null,
          "operation": "create",
          "metadata": null,
          "key": null,
          "payload": {
            "before": null,
            "after": null
          }
        },
        "want": {
          "position": null,
          "operation": "update",
          "metadata": null,
          "key": null,
          "payload": {
            "before": null,
            "after": null
          }
        }
      },
      {
        "description": "set the value under .Payload.After.postgres to true if .Metadata.table=\"postgres\"",
        "config": {
          "field": ".Payload.After.postgres",
          "value": "{{ eq .Metadata.table \"postgres\" }}"
        },
        "have": {
          "position": null,
          "operation": "snapshot",
          "metadata": {
            "table": "postgres"
          },
          "key": null,
          "payload": {
            "before": null,
            "after": {
              "postgres": "false"
            }
          }
        },
        "want": {
          "position": null,
          "operation": "snapshot",
          "metadata": {
            "table": "postgres"
          },
          "key": null,
          "payload": {
            "before": null,
            "after": {
              "postgres": "true"
            }
          }
        }
      }
    ]
  },
  {
    "specification": {
      "name": "field.subset.exclude",
      "summary": "Remove a subset of fields from the record.",
      "description": "Remove a subset of fields from the record, all the other fields are left untouched. \nIf a field is excluded that contains nested data, the whole tree will be removed.  \nIt is not allowed to exclude .Position or .Operation fields.\nNote that this processor only runs on structured data, if the record contains raw JSON data, then use the processor \"decode.json\" to parse it into structured data first.",
      "version": "v0.1.0",
      "author": "Meroxa, Inc.",
      "parameters": {
        "fields": {
          "default": "",
          "description": "Fields is a comma separated list of target fields, as they would be addressed in a Go template (e.g. `.Metadata,.Payload.After.foo`).",
          "type": "string",
          "validations": [
            {
              "type": "required",
              "value": ""
            }
          ]
        }
      }
    },
    "examples": [
      {
        "description": "exclude all fields under payload",
        "config": {
          "fields": ".Payload"
        },
        "have": {
          "position": null,
          "operation": "create",
          "metadata": {
            "key1": "val1"
          },
          "key": null,
          "payload": {
            "before": {
              "bar": "baz"
            },
            "after": {
              "foo": "bar"
            }
          }
        },
        "want": {
          "position": null,
          "operation": "create",
          "metadata": {
            "key1": "val1"
          },
          "key": null,
          "payload": {
            "before": null,
            "after": null
          }
        }
      },
      {
        "description": "exclude metadata, and some fields under payload and key",
        "config": {
          "fields": ".Metadata,.Payload.After.foo,.Key.key1"
        },
        "have": {
          "position": null,
          "operation": "create",
          "metadata": {
            "source": "s3"
          },
          "key": {
            "key1": "val1",
            "key2": "val2"
          },
          "payload": {
            "before": {
              "bar": "baz"
            },
            "after": {
              "foo": "bar",
              "foobar": "baz"
            }
          }
        },
        "want": {
          "position": null,
          "operation": "create",
          "metadata": {},
          "key": {
            "key2": "val2"
          },
          "payload": {
            "before": {
              "bar": "baz"
            },
            "after": {
              "foobar": "baz"
            }
          }
        }
      }
    ]
  },
  {
    "specification": {
      "name": "filter",
      "summary": "Acknowledges all records that get passed to the filter.",
      "description": "Acknowledges all records that get passed to the filter, so the records will be filtered out if \nthe condition provided to the processor is evaluated to \"true\".\nMake sure to add a condition to this processor, otherwise all records will be filtered out.\"",
      "version": "v0.1.0",
      "author": "Meroxa, Inc.",
      "parameters": {}
    },
    "examples": [
      {
        "description": "filter out the record",
        "config": {},
        "have": {
          "position": null,
          "operation": "create",
          "metadata": {
            "key1": "val1"
          },
          "key": null,
          "payload": {
            "before": {
              "bar": "baz"
            },
            "after": {
              "foo": "bar"
            }
          }
        },
        "want": {}
      }
    ]
  },
  {
    "specification": {
      "name": "json.decode",
      "summary": "Decodes a specific field from JSON raw data (string) to structured data.",
      "description": "The processor takes JSON raw data (`string` or `[]byte`)\nfrom the target field, parses it as JSON structured data and stores the decoded\nstructured data in the target field.\n\nThis processor is only applicable to fields under `.Key`, `.Payload`.Before and\n`.Payload.After`, as they can contain structured data.",
      "version": "v0.1.0",
      "author": "Meroxa, Inc.",
      "parameters": {
        "field": {
          "default": "",
          "description": "Field is the target field, as it would be addressed in a Go template (e.g. `.Payload.After.foo`).\nyou can only decode fields that are under .Key and .Payload.",
          "type": "string",
          "validations": [
            {
              "type": "required",
              "value": ""
            },
            {
              "type": "regex",
              "value": "^\\.(Payload|Key).*"
            },
            {
              "type": "exclusion",
              "value": ".Payload"
            }
          ]
        }
      }
    },
    "examples": [
      {
        "description": "Decode the raw data .Key into structured data.",
        "config": {
          "field": ".Key"
        },
        "have": {
          "position": null,
          "operation": "create",
          "metadata": null,
          "key": "{\"after\":{\"data\":4,\"id\":3}}",
          "payload": {
            "before": null,
            "after": null
          }
        },
        "want": {
          "position": null,
          "operation": "create",
          "metadata": null,
          "key": {
            "after": {
              "data": 4,
              "id": 3
            }
          },
          "payload": {
            "before": null,
            "after": null
          }
        }
      },
      {
        "description": "Decode the raw data .Payload.Before.foo into structured data.",
        "config": {
          "field": ".Payload.Before.foo"
        },
        "have": {
          "position": null,
          "operation": "snapshot",
          "metadata": null,
          "key": null,
          "payload": {
            "before": {
              "foo": "{\"before\":{\"data\":4,\"id\":3},\"baz\":\"bar\"}"
            },
            "after": null
          }
        },
        "want": {
          "position": null,
          "operation": "snapshot",
          "metadata": null,
          "key": null,
          "payload": {
            "before": {
              "foo": {
                "baz": "bar",
                "before": {
                  "data": 4,
                  "id": 3
                }
              }
            },
            "after": null
          }
        }
      }
    ]
  },
  {
    "specification": {
      "name": "json.encode",
      "summary": "Encodes a specific field from structured data to JSON raw data (string).",
      "description": "The processor takes data from the target field, encodes it into s JSON value\nand stores the encoded value in the target field.\n\nThis processor is only applicable to fields under `.Key`, `.Payload`.Before and\n`.Payload.After`, as they can contain structured data.",
      "version": "v0.1.0",
      "author": "Meroxa, Inc.",
      "parameters": {
        "field": {
          "default": "",
          "description": "Field is the target field, as it would be addressed in a Go template (e.g. `.Payload.After.foo`).\nyou can only encode fields that are under .Key, .Payload.Before and .Payload.After.",
          "type": "string",
          "validations": [
            {
              "type": "required",
              "value": ""
            },
            {
              "type": "regex",
              "value": "^\\.(Payload|Key).*"
            },
            {
              "type": "exclusion",
              "value": ".Payload"
            }
          ]
        }
      }
    },
    "examples": [
      {
        "description": "Encode a .Key structured data to JSON.",
        "config": {
          "field": ".Key"
        },
        "have": {
          "position": null,
          "operation": "create",
          "metadata": null,
          "key": {
            "tables": [
              "table1,table2"
            ]
          },
          "payload": {
            "before": null,
            "after": null
          }
        },
        "want": {
          "position": null,
          "operation": "create",
          "metadata": null,
          "key": "{\"tables\":[\"table1,table2\"]}",
          "payload": {
            "before": null,
            "after": null
          }
        }
      },
      {
        "description": "Encode a map under .Payload.Before.foo into a JSON value.",
        "config": {
          "field": ".Payload.Before.foo"
        },
        "have": {
          "position": null,
          "operation": "snapshot",
          "metadata": null,
          "key": null,
          "payload": {
            "before": {
              "foo": {
                "baz": "bar",
                "before": {
                  "data": 4,
                  "id": 3
                }
              }
            },
            "after": null
          }
        },
        "want": {
          "position": null,
          "operation": "snapshot",
          "metadata": null,
          "key": null,
          "payload": {
            "before": {
              "foo": "eyJiYXoiOiJiYXIiLCJiZWZvcmUiOnsiZGF0YSI6NCwiaWQiOjN9fQ=="
            },
            "after": null
          }
        }
      }
    ]
  },
  {
    "specification": {
      "name": "unwrap.debezium",
      "summary": "Unwraps a Debezium record from the input OpenCDC record.",
      "description": "In this processor, the wrapped (Debezium) record replaces the wrapping record (being processed) \ncompletely, except for the position.\n\nThe Debezium record's metadata and the wrapping record's metadata is merged, with the Debezium metadata having precedence.\n\nThis is useful in cases where Conduit acts as an intermediary between a Debezium source and a Debezium destination. \nIn such cases, the Debezium record is set as the OpenCDC record's payload, and needs to be unwrapped for further usage.",
      "version": "v0.1.0",
      "author": "Meroxa, Inc.",
      "parameters": {
        "field": {
          "default": ".Payload.After",
          "description": "Field is a reference to the field which contains the Debezium record.\n\nFor more information about record references, see: https://github.com/ConduitIO/conduit-processor-sdk/blob/cbdc5dcb5d3109f8f13b88624c9e360076b0bcdb/util.go#L66.",
          "type": "string",
          "validations": [
            {
              "type": "regex",
              "value": "^.Payload"
            }
          ]
        }
      }
    },
    "examples": [
      {
        "description": "This example how to unwrap a Debezium record from a field nested in a record's\n.Payload.After field. It additionally shows how the key is unwrapped, and the metadata merged.",
        "config": {
          "field": ".Payload.After.nested"
        },
        "have": {
          "position": "dGVzdC1wb3NpdGlvbg==",
          "operation": "create",
          "metadata": {
            "metadata-key": "metadata-value"
          },
          "key": "{\"payload\":\"27\"}",
          "payload": {
            "before": null,
            "after": {
              "nested": "{\n\t\t\t\t\t\t \"payload\": {\n\t\t\t\t\t\t   \"after\": {\n\t\t\t\t\t\t\t \"description\": \"test1\",\n\t\t\t\t\t\t\t \"id\": 27\n\t\t\t\t\t\t   },\n\t\t\t\t\t\t   \"before\": null,\n\t\t\t\t\t\t   \"op\": \"c\",\n\t\t\t\t\t\t   \"source\": {\n\t\t\t\t\t\t\t \"opencdc.readAt\": \"1674061777225877000\",\n\t\t\t\t\t\t\t \"opencdc.version\": \"v1\"\n\t\t\t\t\t\t   },\n\t\t\t\t\t\t   \"transaction\": null,\n\t\t\t\t\t\t   \"ts_ms\": 1674061777225\n\t\t\t\t\t\t },\n\t\t\t\t\t\t \"schema\": {} \n\t\t\t\t\t\t}"
            }
          }
        },
        "want": {
          "position": "dGVzdC1wb3NpdGlvbg==",
          "operation": "create",
          "metadata": {
            "metadata-key": "metadata-value",
            "opencdc.readAt": "1674061777225877000",
            "opencdc.version": "v1"
          },
          "key": "27",
          "payload": {
            "before": null,
            "after": {
              "description": "test1",
              "id": 27
            }
          }
        }
      }
    ]
  },
  {
    "specification": {
      "name": "unwrap.kafkaconnect",
      "summary": "Unwraps a Kafka Connect record from an OpenCDC record.",
      "description": "This processor unwraps a Kafka Connect record from the input OpenCDC record.\n\nThe input record's payload is replaced with the Kafka Connect record.\n\nThis is useful in cases where Conduit acts as an intermediary between a Debezium source and a Debezium destination. \nIn such cases, the Debezium record is set as the OpenCDC record's payload, and needs to be unwrapped for further usage.",
      "version": "v0.1.0",
      "author": "Meroxa, Inc.",
      "parameters": {
        "field": {
          "default": ".Payload.After",
          "description": "Field is a reference to the field which contains the Kafka Connect record.\n\nFor more information about record references, see: https://github.com/ConduitIO/conduit-processor-sdk/blob/cbdc5dcb5d3109f8f13b88624c9e360076b0bcdb/util.go#L66.",
          "type": "string",
          "validations": [
            {
              "type": "regex",
              "value": "^.Payload"
            }
          ]
        }
      }
    },
    "examples": [
      {
        "description": "This example shows how to unwrap a Kafka Connect record.\n\nThe Kafka Connect record is serialized as a JSON string in the .Payload.After field (raw data).\nThe Kafka Connect record's payload will replace the OpenCDC record's payload.\n\nWe also see how the key is unwrapped too. In this case, the key comes in as structured data.\n",
        "config": {
          "field": ".Payload.After"
        },
        "have": {
          "position": "dGVzdCBwb3NpdGlvbg==",
          "operation": "create",
          "metadata": {
            "metadata-key": "metadata-value"
          },
          "key": {
            "payload": {
              "id": 27
            },
            "schema": {}
          },
          "payload": {
            "before": null,
            "after": "{\n\"payload\": {\n  \"description\": \"test2\"\n},\n\"schema\": {}\n}"
          }
        },
        "want": {
          "position": "dGVzdCBwb3NpdGlvbg==",
          "operation": "create",
          "metadata": {
            "metadata-key": "metadata-value"
          },
          "key": {
            "id": 27
          },
          "payload": {
            "before": null,
            "after": {
              "description": "test2"
            }
          }
        }
      }
    ]
  },
  {
    "specification": {
      "name": "unwrap.opencdc",
      "summary": "A processor that unwraps the OpenCDC record saved in one of record's fields.",
      "description": "The unwrap.opencdc processor is useful in situations where a record goes through intermediate \nsystems before being written to a final destination. In these cases, the original OpenCDC record is part of the payload \nread from the intermediate system and needs to be unwrapped before being written.\n\nNote: if the wrapped OpenCDC record is not in a structured data field, then it's assumed that it's stored in JSON format.",
      "version": "v0.1.0",
      "author": "Meroxa, Inc.",
      "parameters": {
        "field": {
          "default": ".Payload.After",
          "description": "Field is a reference to the field which contains the OpenCDC record.\n\nFor more information about record references, see: https://github.com/ConduitIO/conduit-processor-sdk/blob/cbdc5dcb5d3109f8f13b88624c9e360076b0bcdb/util.go#L66.",
          "type": "string",
          "validations": []
        }
      }
    },
    "examples": [
      {
        "description": "",
        "config": {
          "field": ".Payload.After"
        },
        "have": {
          "position": "d3JhcHBpbmcgcG9zaXRpb24=",
          "operation": "create",
          "metadata": {},
          "key": "wrapping key",
          "payload": {
            "before": null,
            "after": {
              "key": {
                "id": "test-key"
              },
              "metadata": {},
              "operation": "update",
              "payload": {
                "before": null,
                "after": {
                  "msg": "string 0e8955b3-7fb5-4dda-8064-e10dc007f00d",
                  "sensor_id": 1250383582,
                  "triggered": false
                }
              },
              "position": "dGVzdC1wb3NpdGlvbg=="
            }
          }
        },
        "want": {
          "position": "d3JhcHBpbmcgcG9zaXRpb24=",
          "operation": "update",
          "metadata": {},
          "key": {
            "id": "test-key"
          },
          "payload": {
            "before": null,
            "after": {
              "msg": "string 0e8955b3-7fb5-4dda-8064-e10dc007f00d",
              "sensor_id": 1250383582,
              "triggered": false
            }
          }
        }
      }
    ]
  },
  {
    "specification": {
      "name": "webhook.http",
      "summary": "HTTP webhook processor",
      "description": "\nA processor that sends an HTTP request to the specified URL, retries on error and \nsaves the response body and, optionally, the response status. \n",
      "version": "v0.1.0",
      "author": "Meroxa, Inc.",
      "parameters": {
        "backoffRetry.count": {
          "default": "0",
          "description": "BackoffRetryCount is the maximum number of retries for an individual record\nwhen backing off following an error.",
          "type": "float",
          "validations": [
            {
              "type": "greater-than",
              "value": "-1"
            }
          ]
        },
        "backoffRetry.factor": {
          "default": "2",
          "description": "BackoffRetryFactor is the multiplying factor for each increment step.",
          "type": "float",
          "validations": [
            {
              "type": "greater-than",
              "value": "0"
            }
          ]
        },
        "backoffRetry.max": {
          "default": "5s",
          "description": "BackoffRetryMax is the maximum waiting time before retrying.",
          "type": "duration",
          "validations": []
        },
        "backoffRetry.min": {
          "default": "100ms",
          "description": "BackoffRetryMin is the minimum waiting time before retrying.",
          "type": "duration",
          "validations": []
        },
        "request.body": {
          "default": ".",
          "description": "RequestBodyRef specifies which field from the input record\nshould be used as the body in the HTTP request.\nThe value of this parameter should be a valid record field reference:\nSee: sdk.NewReferenceResolver",
          "type": "string",
          "validations": []
        },
        "request.contentType": {
          "default": "application/json",
          "description": "ContentType is the value of the Content-Type header.",
          "type": "string",
          "validations": []
        },
        "request.method": {
          "default": "POST",
          "description": "Method is the HTTP request method to be used.",
          "type": "string",
          "validations": []
        },
        "request.url": {
          "default": "",
          "description": "URL used in the HTTP request.",
          "type": "string",
          "validations": [
            {
              "type": "required",
              "value": ""
            }
          ]
        },
        "response.body": {
          "default": ".Payload.After",
          "description": "ResponseBodyRef specifies to which field should the\nresponse body be saved to.\nThe value of this parameter should be a valid record field reference:\nSee: sdk.NewReferenceResolver",
          "type": "string",
          "validations": []
        },
        "response.status": {
          "default": "",
          "description": "ResponseStatusRef specifies to which field should the\nresponse status be saved to.\nThe value of this parameter should be a valid record field reference.\nIf no value is set, then the response status will NOT be saved.\nSee: sdk.NewReferenceResolver",
          "type": "string",
          "validations": []
        }
      }
    },
    "examples": [
      {
        "description": "\nThis example shows how to use the HTTP processor to send a record's .Payload.After field to a dummy HTTP server \nthat replies back with a greeting. \n\nThe record's .Payload.After is overwritten with the response. Additionally, the example shows how to store the \nvalue of the HTTP response's code in the record's metadata'.",
        "config": {
          "backoffRetry.count": "0",
          "backoffRetry.factor": "2",
          "backoffRetry.max": "5s",
          "backoffRetry.min": "100ms",
          "request.body": ".Payload.After",
          "request.contentType": "application/json",
          "request.method": "POST",
          "request.url": "http://127.0.0.1:54321",
          "response.body": ".Payload.After",
          "response.status": ".Metadata[\"http_status\"]"
        },
        "have": {
          "position": null,
          "operation": "Operation(0)",
          "metadata": null,
          "key": null,
          "payload": {
            "before": null,
            "after": "world"
          }
        },
        "want": {
          "position": null,
          "operation": "Operation(0)",
          "metadata": {
            "http_status": "200"
          },
          "key": null,
          "payload": {
            "before": null,
            "after": "hello, world"
          }
        }
      }
    ]
  }
]
