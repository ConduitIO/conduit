// Code generated by MockGen. DO NOT EDIT.
// Source: service.go
//
// Generated by this command:
//
//	mockgen -typed -source=service.go -destination=mock/registry.go -package=mock -mock_names=builtinReg=BuiltinReg,standaloneReg=StandaloneReg . builtinReg,standaloneReg
//

// Package mock is a generated GoMock package.
package mock

import (
	context "context"
	reflect "reflect"

	pconnector "github.com/conduitio/conduit-connector-protocol/pconnector"
	log "github.com/conduitio/conduit/pkg/foundation/log"
	plugin "github.com/conduitio/conduit/pkg/plugin"
	connector "github.com/conduitio/conduit/pkg/plugin/connector"
	gomock "go.uber.org/mock/gomock"
)

// Mockregistry is a mock of registry interface.
type Mockregistry struct {
	ctrl     *gomock.Controller
	recorder *MockregistryMockRecorder
	isgomock struct{}
}

// MockregistryMockRecorder is the mock recorder for Mockregistry.
type MockregistryMockRecorder struct {
	mock *Mockregistry
}

// NewMockregistry creates a new mock instance.
func NewMockregistry(ctrl *gomock.Controller) *Mockregistry {
	mock := &Mockregistry{ctrl: ctrl}
	mock.recorder = &MockregistryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mockregistry) EXPECT() *MockregistryMockRecorder {
	return m.recorder
}

// List mocks base method.
func (m *Mockregistry) List() map[plugin.FullName]pconnector.Specification {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "List")
	ret0, _ := ret[0].(map[plugin.FullName]pconnector.Specification)
	return ret0
}

// List indicates an expected call of List.
func (mr *MockregistryMockRecorder) List() *MockregistryListCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "List", reflect.TypeOf((*Mockregistry)(nil).List))
	return &MockregistryListCall{Call: call}
}

// MockregistryListCall wrap *gomock.Call
type MockregistryListCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockregistryListCall) Return(arg0 map[plugin.FullName]pconnector.Specification) *MockregistryListCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockregistryListCall) Do(f func() map[plugin.FullName]pconnector.Specification) *MockregistryListCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockregistryListCall) DoAndReturn(f func() map[plugin.FullName]pconnector.Specification) *MockregistryListCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// NewDispenser mocks base method.
func (m *Mockregistry) NewDispenser(logger log.CtxLogger, name plugin.FullName, cfg pconnector.PluginConfig) (connector.Dispenser, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewDispenser", logger, name, cfg)
	ret0, _ := ret[0].(connector.Dispenser)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// NewDispenser indicates an expected call of NewDispenser.
func (mr *MockregistryMockRecorder) NewDispenser(logger, name, cfg any) *MockregistryNewDispenserCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewDispenser", reflect.TypeOf((*Mockregistry)(nil).NewDispenser), logger, name, cfg)
	return &MockregistryNewDispenserCall{Call: call}
}

// MockregistryNewDispenserCall wrap *gomock.Call
type MockregistryNewDispenserCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockregistryNewDispenserCall) Return(arg0 connector.Dispenser, arg1 error) *MockregistryNewDispenserCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockregistryNewDispenserCall) Do(f func(log.CtxLogger, plugin.FullName, pconnector.PluginConfig) (connector.Dispenser, error)) *MockregistryNewDispenserCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockregistryNewDispenserCall) DoAndReturn(f func(log.CtxLogger, plugin.FullName, pconnector.PluginConfig) (connector.Dispenser, error)) *MockregistryNewDispenserCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// BuiltinReg is a mock of builtinReg interface.
type BuiltinReg struct {
	ctrl     *gomock.Controller
	recorder *BuiltinRegMockRecorder
	isgomock struct{}
}

// BuiltinRegMockRecorder is the mock recorder for BuiltinReg.
type BuiltinRegMockRecorder struct {
	mock *BuiltinReg
}

// NewBuiltinReg creates a new mock instance.
func NewBuiltinReg(ctrl *gomock.Controller) *BuiltinReg {
	mock := &BuiltinReg{ctrl: ctrl}
	mock.recorder = &BuiltinRegMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *BuiltinReg) EXPECT() *BuiltinRegMockRecorder {
	return m.recorder
}

// Init mocks base method.
func (m *BuiltinReg) Init(arg0 context.Context) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Init", arg0)
}

// Init indicates an expected call of Init.
func (mr *BuiltinRegMockRecorder) Init(arg0 any) *BuiltinRegInitCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Init", reflect.TypeOf((*BuiltinReg)(nil).Init), arg0)
	return &BuiltinRegInitCall{Call: call}
}

// BuiltinRegInitCall wrap *gomock.Call
type BuiltinRegInitCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *BuiltinRegInitCall) Return() *BuiltinRegInitCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *BuiltinRegInitCall) Do(f func(context.Context)) *BuiltinRegInitCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *BuiltinRegInitCall) DoAndReturn(f func(context.Context)) *BuiltinRegInitCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// List mocks base method.
func (m *BuiltinReg) List() map[plugin.FullName]pconnector.Specification {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "List")
	ret0, _ := ret[0].(map[plugin.FullName]pconnector.Specification)
	return ret0
}

// List indicates an expected call of List.
func (mr *BuiltinRegMockRecorder) List() *BuiltinRegListCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "List", reflect.TypeOf((*BuiltinReg)(nil).List))
	return &BuiltinRegListCall{Call: call}
}

// BuiltinRegListCall wrap *gomock.Call
type BuiltinRegListCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *BuiltinRegListCall) Return(arg0 map[plugin.FullName]pconnector.Specification) *BuiltinRegListCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *BuiltinRegListCall) Do(f func() map[plugin.FullName]pconnector.Specification) *BuiltinRegListCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *BuiltinRegListCall) DoAndReturn(f func() map[plugin.FullName]pconnector.Specification) *BuiltinRegListCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// NewDispenser mocks base method.
func (m *BuiltinReg) NewDispenser(logger log.CtxLogger, name plugin.FullName, cfg pconnector.PluginConfig) (connector.Dispenser, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewDispenser", logger, name, cfg)
	ret0, _ := ret[0].(connector.Dispenser)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// NewDispenser indicates an expected call of NewDispenser.
func (mr *BuiltinRegMockRecorder) NewDispenser(logger, name, cfg any) *BuiltinRegNewDispenserCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewDispenser", reflect.TypeOf((*BuiltinReg)(nil).NewDispenser), logger, name, cfg)
	return &BuiltinRegNewDispenserCall{Call: call}
}

// BuiltinRegNewDispenserCall wrap *gomock.Call
type BuiltinRegNewDispenserCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *BuiltinRegNewDispenserCall) Return(arg0 connector.Dispenser, arg1 error) *BuiltinRegNewDispenserCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *BuiltinRegNewDispenserCall) Do(f func(log.CtxLogger, plugin.FullName, pconnector.PluginConfig) (connector.Dispenser, error)) *BuiltinRegNewDispenserCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *BuiltinRegNewDispenserCall) DoAndReturn(f func(log.CtxLogger, plugin.FullName, pconnector.PluginConfig) (connector.Dispenser, error)) *BuiltinRegNewDispenserCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// StandaloneReg is a mock of standaloneReg interface.
type StandaloneReg struct {
	ctrl     *gomock.Controller
	recorder *StandaloneRegMockRecorder
	isgomock struct{}
}

// StandaloneRegMockRecorder is the mock recorder for StandaloneReg.
type StandaloneRegMockRecorder struct {
	mock *StandaloneReg
}

// NewStandaloneReg creates a new mock instance.
func NewStandaloneReg(ctrl *gomock.Controller) *StandaloneReg {
	mock := &StandaloneReg{ctrl: ctrl}
	mock.recorder = &StandaloneRegMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *StandaloneReg) EXPECT() *StandaloneRegMockRecorder {
	return m.recorder
}

// Init mocks base method.
func (m *StandaloneReg) Init(ctx context.Context, connUtilsAddr string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Init", ctx, connUtilsAddr)
}

// Init indicates an expected call of Init.
func (mr *StandaloneRegMockRecorder) Init(ctx, connUtilsAddr any) *StandaloneRegInitCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Init", reflect.TypeOf((*StandaloneReg)(nil).Init), ctx, connUtilsAddr)
	return &StandaloneRegInitCall{Call: call}
}

// StandaloneRegInitCall wrap *gomock.Call
type StandaloneRegInitCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StandaloneRegInitCall) Return() *StandaloneRegInitCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StandaloneRegInitCall) Do(f func(context.Context, string)) *StandaloneRegInitCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StandaloneRegInitCall) DoAndReturn(f func(context.Context, string)) *StandaloneRegInitCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// List mocks base method.
func (m *StandaloneReg) List() map[plugin.FullName]pconnector.Specification {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "List")
	ret0, _ := ret[0].(map[plugin.FullName]pconnector.Specification)
	return ret0
}

// List indicates an expected call of List.
func (mr *StandaloneRegMockRecorder) List() *StandaloneRegListCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "List", reflect.TypeOf((*StandaloneReg)(nil).List))
	return &StandaloneRegListCall{Call: call}
}

// StandaloneRegListCall wrap *gomock.Call
type StandaloneRegListCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StandaloneRegListCall) Return(arg0 map[plugin.FullName]pconnector.Specification) *StandaloneRegListCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StandaloneRegListCall) Do(f func() map[plugin.FullName]pconnector.Specification) *StandaloneRegListCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StandaloneRegListCall) DoAndReturn(f func() map[plugin.FullName]pconnector.Specification) *StandaloneRegListCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// NewDispenser mocks base method.
func (m *StandaloneReg) NewDispenser(logger log.CtxLogger, name plugin.FullName, cfg pconnector.PluginConfig) (connector.Dispenser, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewDispenser", logger, name, cfg)
	ret0, _ := ret[0].(connector.Dispenser)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// NewDispenser indicates an expected call of NewDispenser.
func (mr *StandaloneRegMockRecorder) NewDispenser(logger, name, cfg any) *StandaloneRegNewDispenserCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewDispenser", reflect.TypeOf((*StandaloneReg)(nil).NewDispenser), logger, name, cfg)
	return &StandaloneRegNewDispenserCall{Call: call}
}

// StandaloneRegNewDispenserCall wrap *gomock.Call
type StandaloneRegNewDispenserCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StandaloneRegNewDispenserCall) Return(arg0 connector.Dispenser, arg1 error) *StandaloneRegNewDispenserCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StandaloneRegNewDispenserCall) Do(f func(log.CtxLogger, plugin.FullName, pconnector.PluginConfig) (connector.Dispenser, error)) *StandaloneRegNewDispenserCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StandaloneRegNewDispenserCall) DoAndReturn(f func(log.CtxLogger, plugin.FullName, pconnector.PluginConfig) (connector.Dispenser, error)) *StandaloneRegNewDispenserCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
